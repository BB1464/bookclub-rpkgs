[["index.html", "R Packages Book Club Welcome", " R Packages Book Club The R4DS Online Learning Community 2022-05-13 Welcome Welcome to the bookclub! This is a companion for the book R Packages by Hadley Wickham and Jenny Bryan (work-in-progress 2nd edition, copyright 2022). This companion is available at r4ds.io/rpkgs. This website is being developed by the R4DS Online Learning Community. Follow along, and join the community to participate. This companion follows the R4DS Online Learning Community Code of Conduct. "],["book-club-meetings.html", "Book club meetings", " Book club meetings Each week, a volunteer will present a chapter from the book (or part of a chapter). This is the best way to learn the material. Presentations will usually consist of a review of the material, a discussion, and/or a demonstration of the principles presented in that chapter. More information about how to present is available in the github repo. Presentations will be recorded, and will be available on the R4DS Online Learning Community YouTube Channel. Camera is optional, but encouraged. If we need to slow down and discuss, let me know Most likely someone has the same question We are all here to learn "],["pace.html", "Pace", " Pace We’ll try to cover 1 chapter/week, but… …It’s ok to split chapters when they feel like too much. We will try to meet every week, but will likely take some breaks for holidays, etc. The sessions will be exactly one hour. I encourage the group to adopt a ‘go no matter what’ mentality. "],["introductions.html", "Introductions", " Introductions If you feel comfortable sharing: Who are you? Where are you calling in from? How long have you been using R? What are you most looking forward to during the group? "],["git-and-github.html", "git and GitHub", " git and GitHub It’s worth taking the time to learn git and version control. It’s a topic discussed more in-depth later in the book. If you lead the discussion, it’s best to integrate your materials into this bookdown version of the materials. You’ll need a GitHub account to submit any modifications. If you’re comfortable with git and GitHub Fork the repo to your account. Create a branch to make your changes. Submit a pull request via the R4DS repo for the book PR’s will are reviewed before being pushed and knitted "],["questions-for-the-group.html", "Questions for the group", " Questions for the group Question 1 Question 1 for the group (submit answers to the chat) On a scale from 1 - 5, how familiar are you with using git for version control? 1 = Not at all familiar (a true beginner) to 5 = Very familiar (use git everyday/can handle a merge conflict like a pro) Question 2 for the group On a scale from 1 - 5, how familiar are you with using GitHub? 1 = Not at all familiar (a true beginner) to 5 = Very familiar (I have GitHub account with repositories) Optional Question 3 (depending on feedback) On a scale from 1 - 5, how valuable would it be to devote a week to introducing git and GitHub? 1 = Not at all valuable to 5 = Very valuable "],["resources-to-learn-more-about-git-and-github.html", "Resources to learn more about git and GitHub", " Resources to learn more about git and GitHub Happy Git and GitHub for the useR usethis’s pull request helpers git’s documentation MShiny Cohort 2 Introduction Git for Book Clubs YouTube playlist "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Learning objectives: Explain the book club format. Explain what an R package is. Describe why we should develop packages. Discuss the philosophy behind the use of the devtools and usethis packages in package development. "],["what-is-an-r-package.html", "1.1 What is an R package?", " 1.1 What is an R package? R packages can be defined based on their utility: A means to bundle code, data, documentation, and tests that can easily be shared with others. A package opens up the use of several workflow packages/tools. R packages can be defined by their structure: Discussed throughout the book club At its core, packages are defined by the conventions of how files and directories are organized: \\R; DESCRIPTION file; \\tests; \\data; etc. Packaging Data Analytical Work Reproducibly Using R (and Friends) "],["installing-and-using-packages.html", "1.2 Installing and using packages", " 1.2 Installing and using packages Packages are available via Comprehensive R Archive Network (CRAN) Packages are also available via different public repos GitHub is the most popular. 1.2.1 Installing packages install.packages(&quot;x&quot;) library(&quot;x&quot;) # Getting help package?x help(package = &quot;x&quot;) "],["why-develop-packages.html", "1.3 Why develop packages?", " 1.3 Why develop packages? Allows us to more easily share and use code amongst the team and other collaborators. Saves yourself and your team’s time. Opens up the use of several tools to more efficiently write code. Defines a formal organizational structure of where to put things. Allows us to develop more robust, rigorous, reproducible analyses. Helps us write better code. "],["philosophy-behind-the-tools-of-r-package-development.html", "1.4 Philosophy behind the tools of R Package development", " 1.4 Philosophy behind the tools of R Package development Anything that can be automated, should be automated. Use functions for package development, avoid doing it by hand. To do this, we need to learn the functions/workflow. Our thinking should be on what we want the package to do, not on how to organize a package. This is where the devtools and usethis package come into play. Tools to insulate us from the low-level details of how packages are built. devtools works nicely with RStudio, so that’s the development environment we will use. install.packages(c(&quot;devtools&quot;, &quot;usethis&quot;)) "],["what-if-we-need-more-detail.html", "1.5 What if we need more detail?", " 1.5 What if we need more detail? The official manual is Writing R Extensions. This document is exhaustive. "],["a-note.html", "1.6 A note", " 1.6 A note Don’t get overwhelmed Some stuff you may never use. Remember, an R package at it’s core is just an R/ directory. You are not expected to know everything. We are all learning. None of us is as smart as all of us. It’s okay to say “I don’t know.” We can stop at anytime to discuss. "],["meeting-videos.html", "1.7 Meeting Videos", " 1.7 Meeting Videos 1.7.1 Cohort 1 Meeting chat log 00:07:46 Rex: Brisbane, Australia 00:36:26 Collin Berke: On a scale from 1 - 5, how familiar are you with using git for version control? 00:36:51 Ryan Metcalf: 4 00:36:52 Brendan Lam: 2 00:36:52 Arun Chavan: 3 00:36:53 Larissa Shaughnessy: 2 00:36:54 Isabella Velásquez: 4 00:36:57 Rex Parsons: 3 00:37:19 Collin Berke: On a scale from 1 - 5, how familiar are you with using GitHub? 00:37:38 Rex Parsons: 4 00:37:38 Arun Chavan: 4 00:37:38 Isabella Velásquez: 5 00:37:39 Brendan Lam: 2 00:37:41 Larissa Shaughnessy: 3 00:38:14 Collin Berke: On a scale from 1 - 5, how valuable would it be to devote a week to introducing git and GitHub? 00:38:29 Brendan Lam: 3 00:38:31 Arun Chavan: 2 00:38:35 Larissa Shaughnessy: 4 00:38:35 Ryan Metcalf: 4 00:38:36 Rex Parsons: 4 00:38:48 Isabella Velásquez: I am comfortable with Git, but if it’s valuable for the group! 01:05:36 Rex Parsons: Thanks, Collin! "],["the-whole-game.html", "Chapter 2 The whole game", " Chapter 2 The whole game Learning objectives: Become acquainted with the entire workflow for developing a package. Observe the use of some common functions used in the package development workflow. Understand the process to develop, document, and test a function. Describe the process to install and experiment with a package’s functions. Discuss the roles git and GitHub play in the development of a package. "],["warmupice-breaker.html", "2.1 Warmup/Ice breaker", " 2.1 Warmup/Ice breaker Do you say data (“day - ta”), data (“dah - ta”), or something else? "],["a-few-reminders.html", "2.2 A few reminders", " 2.2 A few reminders If we need to slow down and discuss, let me know. If you have a question, most likely someone else will have the same question. We are all here to learn. Camera is optional, but encouraged. Sessions are recorded and uploaded YouTube. See the pins in the Slack channel for the schedule and sign-ups. "],["load-devtools-and-friends.html", "2.3 Load devtools and friends", " 2.3 Load devtools and friends library(devtools) ## Loading required package: usethis # Check package version packageVersion(&quot;devtools&quot;) ## [1] &#39;2.4.3&#39; Latest version as of the writing of these notes is 2.4.3. "],["what-types-of-functionstools-are-used-during-package-development.html", "2.4 What types of functions/tools are used during package development?", " 2.4 What types of functions/tools are used during package development? Functions fulfilling a specific need. Functions used to facilitate the use of version control (i.e., git and GitHub). Functions to assist in the package development workflow. Setting up the function file Developing documentation (e.g. roxygen2) Testing our code (e.g. testthat) Using a README.Rmd file for documentation. "],["create-the-package.html", "2.5 Create the package", " 2.5 Create the package Use usethis::create_package(\"~path/to/package) Before you run: Consider where these files will be placed Files created (options to view ‘dotfiles’) .Rbuildignore: Files ignored when the package is built from source. .Rproj.user: A directory used by RStudio .gitignore: A file to ignore files for version control. DESCRIPTION: Provides metadata about your package. NAMESPACE: Declares functions to export and external functions to import from other packages. R: The business end of your package. Will hold all of the .R files. projectName.Rproj: File that makes this directory a project. "],["example-package.html", "2.6 Example package", " 2.6 Example package The example package being discussed can be found here. The development can be viewed via the commit history. "],["git-github-a-brief-brief-intro.html", "2.7 git &amp; GitHub, a brief, brief intro", " 2.7 git &amp; GitHub, a brief, brief intro Moving (mirroring) and tracking changes to files (track changes) Topic is certainly more complex Difference between git and GitHub/Bitbucket/GitLab Set up authentication Managing Git(Hub) credentials vignette Happy Git and GitHub for the useR Once you’re set up, you’re good to go. Choose a git client Many, many options (just choose one) Built in Git tab in R Studio GitHub Desktop app usethis helper functions gert package 2.7.1 Fork triangle Diagram taken from Happy Git and GitHub for the useR 2.7.2 Basic workflow 2.7.3 Simplify this workflow Use usethis::create_from_github(\"https://github.com/jennybc/regexcite.git\", fork = TRUE, open = TRUE) Explore the use of the gert package. A simple git client Uses simple R data types (e.g., tibbles) usethis pull request helpers. I ran out of time to review and get comfortable using these functions. Read this vignette here. "],["creating-a-function.html", "2.8 Creating a function", " 2.8 Creating a function use_r() creates a file below the R/ subdirectory. Each new function–when starting out–should get its own file. More complex packages = more functions per file. No other top level code should be in the file. No library() in the function files. Different mechanisms are used to declare dependencies. Scripts &gt;&gt;&gt; packages The book doesn’t cover how to write functions: Functions chapter R4DS Functions chapter in Advanced R Any other resources? Not a novel function. Used for demonstration purposes. #&#39; Create a file name with a date time prefix #&#39; #&#39; @param file_name string A string element representing a file name #&#39; #&#39; @return string value #&#39; #&#39; @export #&#39; #&#39; @examples #&#39; #&#39; create_date_file_name(&quot;data_file.csv&quot;) #&#39; create_date_file_name &lt;- function(file_name){ paste0(gsub(&quot;[-: ]&quot;, &quot;_&quot;, Sys.time()), &quot;_&quot;, file_name) } "],["taking-functions-for-a-test-drive.html", "2.9 Taking functions for a test drive", " 2.9 Taking functions for a test drive load_all() - quickly makes functions available for experimentation. Simulates the process of building, installing, and attaching the package. Technically, function is not in the global environment. Test using exists(\"function-name\", where = globalenv(), inherits = FALSE) This is a much, much faster workflow. It’s good practice to commit once you finish a function. Commits are cheap. "],["checking-package-with-check.html", "2.10 Checking package with check()", " 2.10 Checking package with check() Runs the R CMD check This is the gold standard to get feedback regarding your code. To run this, we use the check() function. Read the output, it tells you what needs to be fixed. Deal with problems early and often. Fix it now, not later. Don’t let work pile up. Harder to fix when problems accumulate. "],["store-package-metadata-in-the-description-file.html", "2.11 Store package metadata in the DESCRIPTION file", " 2.11 Store package metadata in the DESCRIPTION file Package: regexcite Title: Make Regular Expressions More Exciting Version: 0.0.0.9000 Authors@R: person(&quot;Jane&quot;, &quot;Doe&quot;, , &quot;jane@example.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)) Description: Convenience functions to make some common tasks with string manipulation and regular expressions a bit easier. License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a license Encoding: UTF-8 Roxygen: list(markdown = TRUE) RoxygenNote: 7.1.2 "],["pick-a-license-any-license.html", "2.12 Pick a license, any license", " 2.12 Pick a license, any license For personal packages, licensing is not too much of a concern (not a lawyer, though). If you develop a public facing package, then licensing becomes more important. Use a usethis::use_*_license to get up and running quickly with a license. This configures the LISCENSE field in DESCRIPTION "],["documenting-functions.html", "2.13 Documenting functions", " 2.13 Documenting functions Functions are documented using LaTeX. All documentation gets stored in the man/ directory. We don’t have to manually set up documentation. A package called roxygen2 which manages the man/ directory. A roxygen2 skeleton always has #' at the start of each line. When done documenting, run document() to build the man/ files. This is draft documentation. Links will not work. #&#39; Split a string #&#39; #&#39; @param x A character vector with one element. #&#39; @param split What to split on. #&#39; #&#39; @return A character vector. #&#39; @export #&#39; #&#39; @examples #&#39; x &lt;- &quot;alfa,bravo,charlie,delta&quot; #&#39; strsplit(x, split = &quot;,&quot;) "],["the-namespace-file.html", "2.14 The NAMESPACE file", " 2.14 The NAMESPACE file document(): Converts roxygen2 comments into proper R documentation. Updates the NAMESPACE file. Contains all the functions that will be made available to the users of our package. This is based on the @export directive in the roxygen2 skeleton. Don’t edit this by hand. "],["installing-the-package-for-the-first-time.html", "2.15 Installing the package for the first time", " 2.15 Installing the package for the first time Once we have a minimum viable product, install() can be run. Then attach it using library(). At this state, we can test our package as if it was installed. "],["testing-our-package-functions.html", "2.16 Testing our package functions", " 2.16 Testing our package functions We can set up expectations for how our functions work using formalized tests. We’ll discuss this more when we get to the testing chapter. use_testthat() sets up the testing framework. use_test() creates a file for your tests. test() runs all your tests. check() runs R CMD check and your tests "],["using-functions-from-other-packages.html", "2.17 Using functions from other packages", " 2.17 Using functions from other packages We need to import these functions. Use use_package() to show your intent for wanting to use a set of functions within your package. This adds the package to the Imports section of DESCRIPTION. Many options on how to use the functions from imported packages. We will get to this discussion. One way is to be explicit stringr::str_split(). Other options via the use of roxygen2 @import directives Review this example Introduces the rename_files() function Modifying tests Reviews the use of document() and load_all() "],["the-readme-file.html", "2.18 The README file", " 2.18 The README file This is the homepage for the package. The welcome mat. Run use_readme_rmd() to set this up. The purpose of the README.Rmd file is to: Describe the purpose of the package. Provides installation instructions. Highlights a bit of usage. Don’t forget to build the README, build_readme() "],["run-check-and-install-commit-and-push.html", "2.19 Run check() and install(), commit and push", " 2.19 Run check() and install(), commit and push For good measure, run check() and install() Fix any issues. Commit and push "],["meeting-videos-1.html", "2.20 Meeting Videos", " 2.20 Meeting Videos 2.20.1 Cohort 1 Meeting chat log 00:13:51 Ryan Metcalf: I can get the ball rolling, I can try chapters 3 &amp; 4. 00:35:53 Ryan Metcalf: Maybe load `use this`? 00:44:13 Brendan Lam: R4DS is my main reference for writing functions 00:44:46 Rex : looking at other packages source code - but those with s3/s4 methods I find trickier to decipher) 00:47:27 Larissa Shaughnessy: Collin I’m going to put something in the slack. I was digging through my docs for it while you were asking about resources - not sure if it gets into the complexity you are asking for but I do find the examples helpful "],["system-setup.html", "Chapter 3 System setup", " Chapter 3 System setup Learning objectives: How to check which version of R and RStudio you are using Discover devtools Learn about the {usethis} package Understand the distict difference between useRs and developeRs "],["prepare-your-system.html", "3.1 Prepare your system", " 3.1 Prepare your system To start the preparation of development environment, lets get our bearings. R.Version() ## $platform ## [1] &quot;x86_64-pc-linux-gnu&quot; ## ## $arch ## [1] &quot;x86_64&quot; ## ## $os ## [1] &quot;linux-gnu&quot; ## ## $system ## [1] &quot;x86_64, linux-gnu&quot; ## ## $status ## [1] &quot;&quot; ## ## $major ## [1] &quot;4&quot; ## ## $minor ## [1] &quot;1.2&quot; ## ## $year ## [1] &quot;2021&quot; ## ## $month ## [1] &quot;11&quot; ## ## $day ## [1] &quot;01&quot; ## ## $`svn rev` ## [1] &quot;81115&quot; ## ## $language ## [1] &quot;R&quot; ## ## $version.string ## [1] &quot;R version 4.1.2 (2021-11-01)&quot; ## ## $nickname ## [1] &quot;Bird Hippie&quot; sessionInfo() ## R version 4.1.2 (2021-11-01) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=C.UTF-8 LC_NUMERIC=C LC_TIME=C.UTF-8 ## [4] LC_COLLATE=C.UTF-8 LC_MONETARY=C.UTF-8 LC_MESSAGES=C.UTF-8 ## [7] LC_PAPER=C.UTF-8 LC_NAME=C LC_ADDRESS=C ## [10] LC_TELEPHONE=C LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] devtools_2.4.3 usethis_2.1.5 ## ## loaded via a namespace (and not attached): ## [1] bslib_0.3.1 compiler_4.1.2 jquerylib_0.1.4 highr_0.9 ## [5] remotes_2.4.2 prettyunits_1.1.1 tools_4.1.2 testthat_3.1.4 ## [9] digest_0.6.29 pkgbuild_1.3.1 pkgload_1.2.4 jsonlite_1.8.0 ## [13] evaluate_0.15 memoise_2.0.1 lifecycle_1.0.1 rlang_1.0.2 ## [17] cli_3.3.0 rstudioapi_0.13 yaml_2.3.5 xfun_0.31 ## [21] fastmap_1.1.0 withr_2.5.0 stringr_1.4.0 knitr_1.39 ## [25] desc_1.4.1 fs_1.5.2 sass_0.4.1 rprojroot_2.0.3 ## [29] glue_1.6.2 R6_2.5.1 processx_3.5.3 rmarkdown_2.14 ## [33] bookdown_0.26 sessioninfo_1.2.2 purrr_0.3.4 callr_3.7.0 ## [37] magrittr_2.0.3 ps_1.7.0 htmltools_0.5.2 ellipsis_0.3.2 ## [41] stringi_1.7.6 cachem_1.0.6 crayon_1.5.1 brio_1.1.3 Ok, that was fun, but the version check isn’t in the book! We need to follow the author, right? Let’s load some packages to prepare authoring some packages! install.packages(c(&quot;devtools&quot;, &quot;roxygen2&quot;, &quot;testthat&quot;, &quot;knitr&quot;)) NOTE: For some reason, this script caused an infinite loop of restart R, attempt to install, request to restart R, attempt to install…infinity. If this should happen, select No. The author recommends increasing to the Preview version of RStudio Integrated Development Environment (IDE). We are considering outselves developers, right? Usually this isn’t needed or required for common users (we’re not common) It puts you in a position to be subject to bugs (not as many as the daily builds though) Preview version Released version "],["devtools-usethis-and-you.html", "3.2 devtools, usethis, and you", " 3.2 devtools, usethis, and you At some point in your development career…you will find you need to reorder to progress further. This is exactly what happened to the {devtools} package. In 2018, it was reordered and split into seven sub-packages: {remotes} {pkgbuild} {pkgload} {rcmdcheck} {revdepcheck} {sessioninfo} {usethis} What is cool here, we already used one of these packages!!! You can think of devtools as a wrapper providing the ability to: set user-friendly defaults introduce helpful interactive behaviour combine functionality from multiple sub-packages There is a difference in useRs and developeRs. They are: useRs should attach devtools and think of it as the provider of your favorite functions for package development developeRs should NOT depend on devtools, but should instead access functions via the package that is their primary home devtools should rarely appear in the role of foo in a qualified call of the form foo::fcn(). Instead, foo should be the package where fcn() is defined. An exception to this is that we continue to feature devtools::install_github() as the way to install the development version of a package in its README If required, ensure you report bugs to each sub-package Example of how to simulate installing and loading a package (interactive development) library(devtools) load_all() ## ℹ Loading bookclub-rpkgs If used inside an R package, this is the preferred call: pkgload::load_all() ## ℹ Loading bookclub-rpkgs 3.2.1 Personal startup configuration Attach devtools with the following script: library(devtools) Doing this everytime you restart your session gets old…quick! Lets be more efficient with our keystrokes. Let’s edit our .Rprofile file. If it does not exist on your computer, you can run use_devtools() to create it. The output of my command looks like this: use_devtools() • Include this code in &#39;.Rprofile&#39; to make devtools available in all interactive sessions. if (interactive()) { suppressMessages(require(devtools)) } [Copied to clipboard] • Modify &#39;/Users/rmetcalf/.Rprofile&#39; • Restart R for changes to take effect Caution, Warning, HUGE RED FLAG!!!! You are not a Super-person yet! In general, it’s a bad idea to attach packages in .Rprofile, as it invites you to create R scripts that don’t reflect all of their dependencies via explicit calls to library(foo). But devtools is a workflow package that smooths the process of package development and is, therefore, unlikely to get baked into any analysis scripts. Note how we still take care to only attach in interactive sessions. I may be too harsh. The following is a good example when usethis helps and can be added to your .Rprofile. options( usethis.full_name = &quot;Jane Doe&quot;, usethis.description = list( `Authors@R` = &#39;person(&quot;Jane&quot;, &quot;Doe&quot;, email = &quot;jane@example.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)), comment = c(ORCID = &quot;YOUR-ORCID-ID&quot;))&#39;, License = &quot;MIT + file LICENSE&quot;, Version = &quot;0.0.0.9000&quot; ), usethis.protocol = &quot;ssh&quot; ) For history purposes (or at some point it may change….) devtools::install_github(&quot;r-lib/devtools&quot;) devtools::install_github(&quot;r-lib/usethis&quot;) "],["r-build-toolchain.html", "3.3 R build toolchain", " 3.3 R build toolchain Any good developer must have a good compiler. The following three sections will expand on how this may be accomplished via the three main operating systems. NOTE: At this point, these may not be required. The compiler options will becomre important when a source code contains C or C++ code. 3.3.1 Windows On Windows the collection of tools needed for building packages from source is called Rtools. Rtools is NOT an R package and therefore cannot be installed using install.packages('Rtools') During the Rtools installation you may see a window asking you to Select Additional Tasks. DO NOT select the box for Edit the system PATH. DO select the box for Save version information to registry. 3.3.2 macOS If development is on a Mac, you will require Xcode. In shell/terminal run the following code: xcode-select --install NOTE: Xcode is large….like, ~90GBs large (an estimate with all simulators)! There are options to reduce the size and can be found here. Alternatively, you can also download Xcode from the Mac App Store. 3.3.3 Linux Linux install is the simplest (dependent on your distro of choice and package manager). Ensure you include the following: R R development tools For example, on Ubuntu (and Debian): sudo apt-get update &amp; upgrade sudo apt-get install r-base-dev package Other Linux distributions may have alternative commands. 3.3.4 Verify system prep To validate everything is installed or up to date, run the following: devtools::dev_sitrep() Update any packages based on recommendations. "],["meeting-videos-2.html", "3.4 Meeting Videos", " 3.4 Meeting Videos 3.4.1 Cohort 1 Meeting chat log 00:10:39 Ryan Metcalf: 20C = 68F. Awesome Temp! 00:36:24 Brendan Lam: 12.3.1 is my version 00:37:54 Larissa Shaughnessy: This just made me realize I need to update from 12.2 so thanks Brendan! 00:48:53 collinberke: Package for styling your console messages: https://cli.r-lib.org/ 01:05:50 Arun Chavan: Mac 01:05:54 Isabella Velásquez: Also Mac 01:05:59 Larissa Shaughnessy: Mac "],["package-structure-and-state.html", "Chapter 4 Package structure and state", " Chapter 4 Package structure and state Learning objectives: Convert implicit knowledge into the explicit knowledge to create and modify R packages Learn about the various states a package Identify the difference between a package and library Understand the use of .Rbuildignore "],["package-states.html", "4.1 Package states", " 4.1 Package states When you create or modify a package, you work on its source code or source files You interact with the in-development package in its source form R Packages can be in five different states: source: Raw form, editable bundled: Compressed to a single archive file (.tar) binary: Compiled, OS Specific (Windows or Mac). It is implied Linux already has the ability to compile if required. installed: Decompressed into a package library in-memory: Explicitly referenced for use Function calls like install.packages() and devtools::install_github() move a package from source, bundled, or binary states into the installed state. Functions like library() bring your package into memory for immediate use. "],["source-package.html", "4.2 Source package", " 4.2 Source package A source package is just a directory of files with a specific structure Source package contains a DESCRIPTION file, and R directory containing .R files, etc… Some of our group have mentioned authoring or writing packages. Many, this is a new subject. Therefore you can view source files by first navigating to CRAN and by extension to its source repository. (Please correct me if my terminology is incorrect). Examples of CRAN landing page: forcats readxl Examples of GitHub/GitLab (or equivelent) version storage: forcats readxl Note: Some maintainers fail to link their source repos. In this case, google is your friend! Even if a package is not developed on a public platform, you can visit its source in the unofficial, read-only mirror maintained by R-hub. Examples: MASS car Note: This mirror is not the same as exploring the package’s true development venue, because this source and its evolution is just reverse-engineered from the package’s CRAN releases. "],["bundled-package.html", "4.3 Bundled package", " 4.3 Bundled package A bundled package is a package that’s been compressed into a single file By extension of Linux, source tarballs or tar.gz files Implying, source files and directories have been archived using the tar utility .tar stands for Tape Archive creates one file out of many files (with some compression) The files are fully compressed using gzip or GNU Zip gzip creates the .gz extension a bundled package is not source nor installed, but rather, an OS-agnostic storage medium If you need to bundle a package your developing, use devtools::build(). TLDR: The devtools::build() calls pkgbuild::build() under the hood and ultimately R CMD build. For more information see Building package tarballs. All CRAN packages are available in bundled form and can be downloaded from their CRAN landing page. On Mac or Linux, run the following, from shell/terminal, to decompress and un-archive: tar xvf forcats_0.4.0.tar.gz Quick explanation, you are calling on the tar utility. -x is extract, -v is verbose (show the output…makes you feel good to know something is happening), and -f is filename, uses the same filename as the archive. Windows users, I’m sorry, you’re going to have to use some type of utility like 7-Zip, WinZip, or WinRAR to decompress and un-archive. Windows does not have a native utility to accomplish this action. (Feel welcome to share your PowerShell examples if I’m incorrect). Note: A bit of research turns up, the tar utility was added to Windows 10, circa 2018. Earlier versions of Windows would require a third-party application. Figure 4.1: Side-by-side comparison of source, bundled, and binary package. The main differences between a source package and an uncompressed bundle are: Vignettes have been built, so rendered outputs, such as HTML, appear below inst/doc/ and a vignette index appears in the build/ directory, usually alongside a PDF package manual. A local source package might contain temporary files used to save time during development, like compilation artifacts in src/. These are never found in a bundle. Any files listed in .Rbuildignore are not included in the bundle. These are typically files that facilitate your development process, but that should be excluded from the distributed product. 4.3.1 .Rbuildignore It is rare to contemplate the .tar.gz structure. However, it IS important to understand the .Rbuildignore file. Rbuildignore controls which files from the source package make it into the downstream forms The concept is similar to other .*ignore files. Exclude versus Include Each line of .Rbuildignore is a Perl-compatible regular expression case insensitive if the regex matches, the file is excluded You must anchor the regular expression for example ^notes$ will exclude any filename string containing notes. a less specific (or more automated method) is to use usethis::use_build_ignore(\"notes\") Rbuildignore is a means to compromise your development environment with CRAN’s requirements. The affected files fall into two broad, semi-overlapping classes: Files that help you generate package contents programmatically. Examples: Using README.Rmd to generate an informative and current README.md. Storing .R scripts to create and update internal or exported data. Files that drive package development, checking, and documentation, outside of CRAN’s purview. Examples: Files relating to the RStudio IDE. Using the pkgdown package to generate a website. Configuration files related to continuous integration/deployment and monitoring test coverage. A non-exhaustive list of typical entries in the .Rbuildignore file ^.*\\.Rproj$ # Designates the directory as an RStudio Project ^\\.Rproj\\.user$ # Used by RStudio for temporary files ^README\\.Rmd$ # An Rmd file used to generate README.md ^LICENSE\\.md$ # Full text of the license ^cran-comments\\.md$ # Comments for CRAN submission ^data-raw$ # Code used to create data included in the package ^pkgdown$ # Resources used for the package website ^_pkgdown\\.yml$ # Configuration info for the package website ^\\.github$ # Contributing guidelines, CoC, issue templates, etc. Note: The commmented text above should not be included in the Rbuildignore file and are only used for explination of each entry. Note: Remember that usethis::use_build_ignore() is an attractive way to manage this file. "],["binary-package.html", "4.4 Binary package", " 4.4 Binary package Binary packages are used when a colleague doesn’t have development tools installed Uses a single file Binary packages are OS-specific Mac: .tgz Windows: .zip Linux: generally already have libraries capable of working with binary packages To make a binary package use devtools::build(binary=TRUE) Under the hood, calls pkgbuild::build(binary=TRUE) and ultimately R CMD INSTALL --build For more information see Building binary packages section of Writing R Extensions The primary maker and distributor of binary is CRAN, not individual maintainers. Examples of downloading binary packages (image) Figure 4.2: Forcats CRAN Binary Download Options Ironically, this download process is exactly what is happening when you call install.packages() Decompressing a binary packages looks rather different from source or bundled package forms Notible Differences: There are no .R files in R/ directory. Instead a more efficient form is used Meta/ directory contains a number or .rds files Actual help/ and html/ are used instead of man/ If you had any code in src/ directory, it will not be in libs/ Windows binary also contains i386/ and x64/ for 32 or 64 bit environments Anything in data/ is converted to more efficient forms Contents of inst/ are moved to top-level (for example vignette files are not in doc/) Some files and folders have been dropped such as README, build/, test/, and vignettes/ . ├── DESCRIPTION ├── INDEX ├── LICENSE ├── Meta │ ├── Rd.rds │ ├── data.rds │ ├── features.rds │ ├── hsearch.rds │ ├── links.rds │ ├── nsInfo.rds │ ├── package.rds │ └── vignette.rds ├── NAMESPACE ├── NEWS.md ├── R │ ├── forcats │ ├── forcats.rdb │ └── forcats.rdx ├── data │ ├── Rdata.rdb │ ├── Rdata.rds │ └── Rdata.rdx ├── doc │ ├── forcats.R │ ├── forcats.Rmd │ ├── forcats.html │ └── index.html ├── help │ ├── AnIndex │ ├── aliases.rds │ ├── figures │ │ ├── README-ordered-plot-1.png │ │ ├── README-unordered-plot-1.png │ │ └── logo.png │ ├── forcats.rdb │ ├── forcats.rdx │ └── paths.rds └── html ├── 00Index.html └── R.css 7 directories, 33 files "],["installed-package.html", "4.5 Installed package", " 4.5 Installed package Installed package is a binary package that has been decompressed into a package library WARNING, COMPLICATED FIGURE AHEAD! LETS DISCUSS IT! In a perfect world, stringing together a set of simple steps: source -&gt; bundle, bundle -&gt; binary, binary -&gt; installed In the REAL world, it isn’t as simple Figure 4.3: Many methods for converting between package states. The cool part of this process, and why this figure is important is, the R CMD INSTALL is the primary service for all forms of packaging. For more information check out Installing packages section of Installing packages section. Devtools exposes a family of install_*() to address needs beyond only install.packages(). Again, more information can be found in remotes package. library(remotes) ## ## Attaching package: &#39;remotes&#39; ## The following objects are masked from &#39;package:devtools&#39;: ## ## dev_package_deps, install_bioc, install_bitbucket, install_cran, ## install_deps, install_dev, install_git, install_github, ## install_gitlab, install_local, install_svn, install_url, ## install_version, update_packages ## The following object is masked from &#39;package:usethis&#39;: ## ## git_credentials funs &lt;- as.character(lsf.str(&quot;package:remotes&quot;)) grep(&quot;^install_.+&quot;, funs, value = TRUE) ## [1] &quot;install_bioc&quot; &quot;install_bitbucket&quot; &quot;install_cran&quot; ## [4] &quot;install_deps&quot; &quot;install_dev&quot; &quot;install_git&quot; ## [7] &quot;install_github&quot; &quot;install_gitlab&quot; &quot;install_local&quot; ## [10] &quot;install_remote&quot; &quot;install_svn&quot; &quot;install_url&quot; ## [13] &quot;install_version&quot; install_github() is the flagship example of this remots library. using devtools/remotes install_*() functions aim at making things possible with base tooling a bit easier or more explicit Example is install_version() which installs a specific version of a CRAN package .Rinstignore lets you keep files present in a package bundle out of the installed package. The use of .Rinstignore is rather obscure or rarely needed TODO: Revisit this section later with respect to pak https://pak.r-lib.org. "],["in-memory-package.html", "4.6 In-memory package", " 4.6 In-memory package Let’s discuss library(usethis). library(usethis) create_package(&quot;~/newpackage&quot;) usethis package has been loaded into memory and attached to the search path Loading and Attaching packages is not important during writing scripts….IT IS EXTREMELY IMPORTANT WHEN WRITING PACKAGES See search path for more details We will learn in section 5.4 “Test drive with load_all()” how devtools::load_all() accelerates development, allowing you to load a source package directly to memory. "],["package-libraries.html", "4.7 Package libraries", " 4.7 Package libraries When calling library(foo), R looks through the current libraries for an installed package foo, and if successful, makes it available. Definition: Library: is a directory containing installed packages. Definition: Packages: are functional instructions to process information. These terms are often misused and reinforced within our vernacular (language dictionary). We use the library() function to load a package. As package prospect R Package Developers, it is a good idea to set the distinction between library and package early To see .libPaths() on Windows, use the following function call: .libPaths() lapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE) To see `.libPaths() on macOS, use the following function call: .libPaths() lapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE) NOTE TO SELF…THESE ARE THE SAME CALLS Considering the output, we view two things: A user library A system-level or global library A user library is typical for a Windows installation, but an opt-in for Mac Users. Depending on your development environment the idea would mean, I can delete my user packages but maintain my base R installation. (Lets discuss this for a moment). If you’re on macOS and only see one library, there is no urgent need to change anything. But next time you upgrade R, consider creating a user-level library. By default, R looks for a user library found at the path stored in the environment variable R_LIBS_USER, which itself defaults to ~/Library/R/x.y/library. When you install, R x.y.z and prior to installing any add-on packages, use dir.create(\"~/Library/R/x.y/library\") to set up a user library. Now you will have the library setup seen above. Alternatively, you could setup a user library elsewhere and tell R about that by setting the R_LIBS_USER environment variable in .Renviron. In is implied you need to re-install user packages for a minor version of R. (3.5.0 to 3.6.0). You generally do not require this for a patch release (3.6.0 to 3.6.1). NOTE: The x.y.z reference previously can also be read as major.minor.patch and is common within software engineering. As we grow and become more sophisticated, our management of packages will become more intricate. Examples like renv and its predecessor packrat() automate the process of managing project-specific libraries An example woudl be loading specific versions of an environment to test forward and backward compatibility Reverse dependency checks are another example of managing the library search path The main levers that control which libraries are active: Environment variables, like R_LIBS and R_LIBS_USER, which are consulted at startup Calling .libPaths() with one or more filepaths Executing small snippets of code with a temporarily altered library search path via withr::with_libpaths() Arguments to individual functions, like install.packages(lib =) and library(lib.loc =). NOTE: library() should NEVER be used inside a package. There are other mechinisims for declaring dependencies. We’ll discuss this more in chapter 13. "],["meeting-videos-3.html", "4.8 Meeting Videos", " 4.8 Meeting Videos 4.8.1 Cohort 1 Meeting chat log 00:30:11 Isabella Velásquez: RSPM: https://www.rstudio.com/products/package-manager/ 00:30:16 Isabella Velásquez: and it’s called PyPI! 01:04:57 Isabella Velásquez: https://pypi.org/ 01:15:53 collinberke: Microsoft’s capture of R Packages: https://mran.microsoft.com/documents/rro/reproducibility "],["fundamental-development-workflows.html", "Chapter 5 Fundamental development workflows", " Chapter 5 Fundamental development workflows Learning objectives: When and how to make an R package. RStudio projects. Why not to mess with your working directory. Test driving code. "],["survey-the-existing-landscape.html", "5.1 Survey the existing landscape", " 5.1 Survey the existing landscape Be sure that the package doesn’t overlap too much with existing packages: Is there an existing package that does what you need? Could you contribute to a similar, existing package to add the functionality you need? List of packages on CRAN Payoffs: Product: your life will be better when this functionality is implemented formally, in a package. Process: greater mastery of R will make you more effective in your work. "],["considerations.html", "5.2 Considerations", " 5.2 Considerations Ensure that the package fits in well within the domain of existing R packages. For modelling packages, using the hardhat package helps the developer use best practices and ensures that the resulting package can be used within the tidymodels ecosystem (and get used more). You may also want to include consider including appropriate methods to be consistent with other related, packages. For example, many modelling packages have predict, plot, and summary methods, and users may expect this functionality from a new package that you create. "],["naming-your-package.html", "5.3 Naming your package", " 5.3 Naming your package See the naming convention used for existing packages: List of packages on CRAN Laws: The name can only consist of letters, numbers, and periods, i.e., .. It must start with a letter. It cannot end with a period. (no underscores or hyphens) Recommendations: No periods. Easy to Google. Avoid confusion with an existing R package (not on CRAN/Bioconductor/GitHub) or well known package from other language (numpy, pandas) All lower case if possible. Abbreviations to reduce name length (brms = Bayesian Regression Models using Stan) Adding in capital R’s for fun. Not getting sued (facebook Rfacebook, Dropbox RDrop, apple appler) Here is a fun blog post on naming R packages by Nick Tierney. Also recommend checking out his package greta which is really cool and has useful example of using python (to access tensorflow) from R in a package. He also has a guide on renaming an R package "],["creating-a-new-package.html", "5.4 Creating a new package", " 5.4 Creating a new package Call usethis::create_package('yourPackageName') In RStudio, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way. (I prefer to use RStudio - show using create_package from bash) 5.4.1 What does this do? This creates your project structure for you: R/ directory DESCRIPTION file NAMESPACE file pkgName.Rproj file .Rbuildignore &amp; .gitignore DO NOT use package.skeleton() - it creates a package which will lead to errors when running R CMD build and is not consistent with the devtools style of development. 5.4.2 Where to put this package? This is distinct from where your R packages are installed. It makes sense to put this in a similar area to where you keep your other R projects. Within my /user/documents/, I have R_projects/ and R_pkgs/ "],["using-rstudio-projects.html", "5.5 Using RStudio Projects", " 5.5 Using RStudio Projects You can use devtools without using RStudio and visa versa, but it’s not as nice. 5.5.1 Benefits of RStudio Projects Each project is isolated and code is contained within the project. Easy to start up a project in a fresh instance of RStudio. Useful features that we probably all already use from RStudio. Keyboard shortcuts for common code development tasks (build, load, test, document, check) alt-shift-k for shortcuts 5.5.2 Make an R Project for an existing package If you already have an R package which isn’t within an R Project, you can: In RStudio, do File &gt; New Project &gt; Existing Directory. Call usethis::create_package() with the path to the pre-existing R source package. Call usethis::use_rstudio(), with the active usethis project set to an existing R package. In practice, this probably means you just need to make sure working directory is inside the pre-existing package. (using usethis::use_rstudio() from bash fixes the problem of the other not being created) 5.5.3 R Project tidbits A directory for an R Project will have a .Rproj file, typically with the same name as the directory (and the package if the project is a package). It’s best case for all of these names to be the same. (If you want to change the name, refer to that guide from Nick on renaming an R package.) This file is just a text file and you don’t need to modify it by hand. I can’t think of a reason why I’d need to but it’s possible from ‘Project Options…’ in RStudio (drop down on top right). Launch an R Project by double clicking the .Rproj file or from within RStudio. "],["rstudio-usethis-and-working-directories.html", "5.6 RStudio, usethis and working directories", " 5.6 RStudio, usethis and working directories usethis functions don’t take a path (i.e. usethis::use_r(\"new_fx\")) usethis assumes that the following coincide: The current RStudio Project. The active usethis project. Current working directory for the R process. It’s therefore much easier to not mess with your working directory for your R console. Leave it as the project directory so that when you’re calling functions from usethis, it puts things in the right place. You can double check that these three directories are coinciding by running: usethis::proj_sitrep() ## • working_directory: &#39;/home/runner/work/bookclub-rpkgs/bookclub-rpkgs&#39; ## • active_usethis_proj: &lt;unset&gt; ## • active_rstudio_proj: &lt;unset&gt; ## • There is currently no active usethis project. ## usethis attempts to activate a project upon first need. ## Call `proj_get()` to initiate project discovery. ## Call `proj_set(&quot;path/to/project&quot;)` or `proj_activate(&quot;path/to/project&quot;)` to provide ## an explicit path. Similarly, when you run helper functions from devtools to develop your package (document(), check(), test()), these are also expecting your working directory to be the project directory. The also expect that your project follows the conventions of project structure (test scripts living in tests/, R code living in R/, vignettes living in vignettes/ compiled code living in src/, images living in man/figures/ etc). "],["test-driving-a-package.html", "5.7 Test driving a package", " 5.7 Test driving a package pkgload diagram 5.7.1 Using load_all() Running load_all() is the fastest way to re-load the functions in your package as if you had installed it and run library(pkgName). It is MUCH faster than install() (especially if you have compiled code in the package - show edits in DSSP). 5.7.2 Using test() Running test() runs load_all() and then the test files that live in tests/testthat/. If you have a test file which captures the behaviour in the function that you desire, you can quickly assess whether the changes you make in the function have worked by running test(). 5.7.3 Coping with being impatient check() can take a long time and leave your console occupied. A solution to this is to run using the build tab (ctrl-shift-E) or as a separate job: job::job({check()}) To test examples in your documentation without running check(): run_examples() 5.7.4 My (bad) habit I like to have a working_space.Rmd in the package directory which I use to test package code away from the console. You’ll get a NOTE on the check: N checking top-level files … Non-standard file/directory found at top level: &#39;working_space.Rmd&#39; But you could also add this to .Rbuildignore/.gitignore. It can be tricky to incorporate everything into a test script, and sometimes you may want to have a closer look at what’s going on within a function. This can more easily be done by throwing some earlier return()s into your package functions, run load_all() to make them effective and then running code in your working_space.Rmd file. "],["meeting-videos-4.html", "5.8 Meeting Videos", " 5.8 Meeting Videos 5.8.1 Cohort 1 Meeting chat log 00:25:44 Ryan Metcalf: Mac: Opt-&gt;Shift-&gt;k 00:32:09 Ryan Metcalf: The first link wasn’t credible. There is a `{changer}` additional add in, that may aid in naming convention change. https://cran.r-project.org/web/packages/changer/changer.pdf 00:34:36 Isabella Velásquez: here’s an article (by Nick Tierney!) on how to change package names (note, it is from 2017): https://www.njtierney.com/post/2017/10/27/change-pkg-name/ 00:57:23 Isabella Velásquez: https://twitter.com/jayyqi/status/1228049523806617601?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1228049523806617601%7Ctwgr%5E%7Ctwcon%5Es1_&amp;ref_url=https%3A%2F%2Fivelasq.rbind.io%2Fblog%2Fyou-cran-do-it%2F 01:01:12 Brendan Lam: This is helpful^ Thanks! 01:01:44 Isabella Velásquez: Is this what you are referring to? RMarkdown Driven Development (RmdDD) https://emilyriederer.netlify.app/post/rmarkdown-driven-development/ 01:03:25 collinberke: Yes! 01:04:04 collinberke: https://www.youtube.com/watch?v=eMWgu9OQ0m8&amp;list=PL3x6DOfs2NGiXMln8bxY7e0XgA5z1cp-8&amp;index=4 01:04:24 Isabella Velásquez: Thanks! 01:06:39 Ryan Metcalf: https://www.rstudio.com/conference/ 01:06:49 Isabella Velásquez: HAVE to 01:10:21 Isabella Velásquez: Here’s a video of Emily’s talk from a conf in the past : https://www.youtube.com/watch?v=B6YO5nW46SU 01:16:22 Ryan Metcalf: `git checkout -b &lt;name of your branch&gt;` "],["the-package-within.html", "Chapter 6 The package within", " Chapter 6 The package within Purpose To walk through the building of a toy package, with an emphasis on the package’s R code and how it differs from R code in a script. Data analysis script \\(\\rightarrow\\) Isolate and extract the reusable data and logic from the script \\(\\rightarrow\\) Put code into an R package \\(\\rightarrow\\) Use package in a newly simplified script "],["alfa-a-script-that-works.html", "6.1 Alfa: a script that works", " 6.1 Alfa: a script that works A fictional script for a dataset of people who went for a swim. Where did you swim and how hot was it outside? infile &lt;- &quot;swim.csv&quot; (dat &lt;- read.csv(infile)) #&gt; name where temp #&gt; 1 Adam beach 95 #&gt; 2 Bess coast 91 #&gt; 3 Cora seashore 28 #&gt; 4 Dale beach 85 #&gt; 5 Evan seaside 31 Observations were classified as American or British based on how they described the beach: dat$english[dat$where == &quot;beach&quot;] &lt;- &quot;US&quot; dat$english[dat$where == &quot;coast&quot;] &lt;- &quot;US&quot; dat$english[dat$where == &quot;seashore&quot;] &lt;- &quot;UK&quot; dat$english[dat$where == &quot;seaside&quot;] &lt;- &quot;UK&quot; Temperatures were converted to Celsius: dat$temp[dat$english == &quot;US&quot;] &lt;- (dat$temp[dat$english == &quot;US&quot;] - 32) * 5/9 dat #&gt; name where temp english #&gt; 1 Adam beach 35.0 US #&gt; 2 Bess coast 32.8 US #&gt; 3 Cora seashore 28.0 UK #&gt; 4 Dale beach 29.4 US #&gt; 5 Evan seaside 31.0 UK Data is written back to a csv file. A timestamp is also captured in the filename. now &lt;- Sys.time() timestamp &lt;- format(now, &quot;%Y-%B-%d_%H-%M-%S&quot;) (outfile &lt;- paste0(timestamp, &quot;_&quot;, sub(&quot;(.*)([.]csv$)&quot;, &quot;\\\\1_clean\\\\2&quot;, infile))) #&gt; [1] &quot;2022-April-17_07-14-16_swim_clean.csv&quot; write.csv(dat, file = outfile, quote = FALSE, row.names = FALSE) "],["bravo-a-better-script-that-works.html", "6.2 Bravo: a better script that works", " 6.2 Bravo: a better script that works There’s a package that lurks within the original script (apparently) Suboptimal coding practices like repetitive code and mixing of code and data Next version of the script: library(tidyverse) infile &lt;- &quot;swim.csv&quot; dat &lt;- read_csv(infile, col_types = cols(name = &quot;c&quot;, where = &quot;c&quot;, temp = &quot;d&quot;)) lookup_table &lt;- tribble( ~where, ~english, &quot;beach&quot;, &quot;US&quot;, &quot;coast&quot;, &quot;US&quot;, &quot;seashore&quot;, &quot;UK&quot;, &quot;seaside&quot;, &quot;UK&quot; ) dat &lt;- dat %&gt;% left_join(lookup_table) #&gt; Joining, by = &quot;where&quot; f_to_c &lt;- function(x) (x - 32) * 5/9 dat &lt;- dat %&gt;% mutate(temp = if_else(english == &quot;US&quot;, f_to_c(temp), temp)) dat #&gt; # A tibble: 5 × 4 #&gt; name where temp english #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Adam beach 35 US #&gt; 2 Bess coast 32.8 US #&gt; 3 Cora seashore 28 UK #&gt; 4 Dale beach 29.4 US #&gt; 5 Evan seaside 31 UK now &lt;- Sys.time() timestamp &lt;- function(time) format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;) outfile_path &lt;- function(infile) { paste0(timestamp(now), &quot;_&quot;, sub(&quot;(.*)([.]csv$)&quot;, &quot;\\\\1_clean\\\\2&quot;, infile)) } write_csv(dat, outfile_path(infile)) Key features of this code: using functions from tidyverse packages different “beach” words are stored in a lookup table. This makes it easier to add words in the future. f_to_c(), timestamp(), and outfile_path() functions now hold the logic for converting temperatures and forming the timestamped output file name. "],["charlie-external-helpers.html", "6.3 Charlie: external helpers", " 6.3 Charlie: external helpers Move reusable data and logic out of the analysis script and into separate files. library(tidyverse) localize_beach &lt;- function(dat) { lookup_table &lt;- read_csv( &quot;beach-lookup-table.csv&quot;, col_types = cols(where = &quot;c&quot;, english = &quot;c&quot;) ) left_join(dat, lookup_table) } f_to_c &lt;- function(x) (x - 32) * 5/9 celsify_temp &lt;- function(dat) { mutate(dat, temp = if_else(english == &quot;US&quot;, f_to_c(temp), temp)) } now &lt;- Sys.time() timestamp &lt;- function(time) format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;) outfile_path &lt;- function(infile) { paste0(timestamp(now), &quot;_&quot;, sub(&quot;(.*)([.]csv$)&quot;, &quot;\\\\1_clean\\\\2&quot;, infile)) } High-level helper functions like localize_beach() and celsify_temp(), were added to the pre-existing helpers (f_to_c(), timestamp(), and outfile_path()) library(tidyverse) source(&quot;cleaning-helpers.R&quot;) infile &lt;- &quot;swim.csv&quot; dat &lt;- read_csv(infile, col_types = cols(name = &quot;c&quot;, where = &quot;c&quot;, temp = &quot;d&quot;)) (dat &lt;- dat %&gt;% localize_beach() %&gt;% celsify_temp()) #&gt; Joining, by = &quot;where&quot; #&gt; # A tibble: 5 × 4 #&gt; name where temp english #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Adam beach 35 US #&gt; 2 Bess coast 32.8 US #&gt; 3 Cora seashore 28 UK #&gt; 4 Dale beach 29.4 US #&gt; 5 Evan seaside 31 UK write_csv(dat, outfile_path(infile)) Script is now much shorter (and cleaner). However, whether it’s easier depends on personal preference and what “feels” easier to work with. "],["delta-an-attempt-at-a-package.html", "6.4 Delta: an attempt at a package", " 6.4 Delta: an attempt at a package Use usethis::create_package() to scaffold a new R package Copy cleaning-helpers.R into the new package, specifically, to R/cleaning-helpers.R Copy beach-lookup-table.csv into the top-level of the new source package install package Script we’re trying to run: library(tidyverse) library(delta) # originally source(&quot;cleaning-helpers.R&quot;) infile &lt;- &quot;swim.csv&quot; dat &lt;- read_csv(infile, col_types = cols(name = &quot;c&quot;, where = &quot;c&quot;, temp = &quot;d&quot;)) dat &lt;- dat %&gt;% localize_beach() %&gt;% celsify_temp() write_csv(dat, outfile_path(infile)) Results when we try to run this code: library(tidyverse) library(delta) infile &lt;- &quot;swim.csv&quot; dat &lt;- read_csv(infile, col_types = cols(name = &quot;c&quot;, where = &quot;c&quot;, temp = &quot;d&quot;)) dat &lt;- dat %&gt;% localize_beach() %&gt;% celsify_temp() &gt; Error in localize_beach(.) : could not find function &quot;localize_beach&quot; write_csv(dat, outfile_path(infile)) &gt; Error in outfile_path(infile) : could not find function &quot;outfile_path&quot; Despite calling our library(delta), none of the functions were actually available to use. This is because we only attached the package, rather than sourcing the file with helper functions. Attaching a package does not put the functions in the global workspace. We can export these functions properly by putting @export in the roxygen comment above each function #&#39; @export celsify_temp &lt;- function(dat) { mutate(dat, temp = if_else(english == &quot;US&quot;, f_to_c(temp), temp)) } Now our script works (sort of)! library(tidyverse) library(delta) infile &lt;- &quot;swim.csv&quot; dat &lt;- read_csv(infile, col_types = cols(name = &quot;c&quot;, where = &quot;c&quot;, temp = &quot;d&quot;)) dat &lt;- dat %&gt;% localize_beach() %&gt;% celsify_temp() #&gt; Error: &#39;beach-lookup-table.csv&#39; does not exist in current working directory (&#39;/Users/jenny/tmp&#39;). write_csv(dat, outfile_path(infile)) Problem: You can’t dump CSV files into the source of an R package and expect it to work. Despite this, you can still install and attach this package. This means that broken packages can still be used. To prevent this, you should run R CMD check or check() often during development. Doing so will alert you to the problem: * installing *source* package ‘delta’ ... ** using staged installation ** R ** byte-compile and prepare package for lazy loading Error in library(tidyverse) : there is no package called ‘tidyverse’ Error: unable to load R code in package ‘delta’ Execution halted ERROR: lazy loading failed for package ‘delta’ * removing ‘/Users/brendan/RScripts/delta.Rcheck/delta’ What are the reasons behing these errors? Package was declared incorrectly While you can load a package using library(tidyverse) in a script, dependencies on other packages must be declared in the DESCRIPTION "],["echo-a-working-package.html", "6.5 Echo: a working package", " 6.5 Echo: a working package Now we’ll make a package that actually works: lookup_table &lt;- dplyr::tribble( ~where, ~english, &quot;beach&quot;, &quot;US&quot;, &quot;coast&quot;, &quot;US&quot;, &quot;seashore&quot;, &quot;UK&quot;, &quot;seaside&quot;, &quot;UK&quot; ) #&#39; @export localize_beach &lt;- function(dat) { dplyr::left_join(dat, lookup_table) } f_to_c &lt;- function(x) (x - 32) * 5/9 #&#39; @export celsify_temp &lt;- function(dat) { dplyr::mutate(dat, temp = dplyr::if_else(english == &quot;US&quot;, f_to_c(temp), temp)) } now &lt;- Sys.time() timestamp &lt;- function(time) format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;) #&#39; @export outfile_path &lt;- function(infile) { paste0(timestamp(now), &quot;_&quot;, sub(&quot;(.*)([.]csv$)&quot;, &quot;\\\\1_clean\\\\2&quot;, infile)) } Note: To fix our initial problem with loading a CSV file, we’ve created lookup_table to create a data frame instead. However, Chapter 14 provides more guidance and recommendations on how to load datasets properly. Other Note: When calling functions from other packages, we should specify the package that we’re using (e.g., dplyr::mutate()). Moreover, we should identify the specific package being used, rather than the meta-package (e.g., do not use tidyverse::mutate()) All of the user-facing functions have an @export tag in their roxygen comment, which means that devtools::document() adds them correctly to the NAMESPACE file. This package can be installed, but we receive 1 note and 1 warning: * checking R code for possible problems ... NOTE celsify_temp: no visible binding for global variable ‘english’ celsify_temp: no visible binding for global variable ‘temp’ Undefined global functions or variables: english temp * checking for missing documentation entries ... WARNING Undocumented code objects: ‘celsify_temp’ ‘localize_beach’ ‘outfile_path’ All user-level objects in a package should have documentation entries. See chapter ‘Writing R documentation files’ in the ‘Writing R Extensions’ manual. Translation of first warnings: no visible binding for global variable ‘english’ and no visible binding for global variable ‘temp’ Using bare variable names like english and temp looks suspicious because you’re using unquoted variable names from dplyr inside a package. defining these variables globally eliminates the note: option 1 (then you should also put utils in Imports) utils::globalVariables(c(&quot;english&quot;, &quot;temp&quot;)) option 2 english &lt;- temp &lt;- NULL The other note we received from R: \"Undocumented code objects: ‘celsify_temp’ ‘localize_beach’ ‘outfile_path’ All user-level objects in a package should have documentation entries.\" This is caused by not documenting exported functions. Using roxygen comments to document it should solve the problem. "],["foxtrot-build-time-vs.-run-time.html", "6.6 Foxtrot: build time vs. run time", " 6.6 Foxtrot: build time vs. run time Another problem: For this package, the timestamps don’t seem to work properly.. Sys.time() #&gt; [1] &quot;2022-02-24 20:49:59 PST&quot; outfile_path(&quot;INFILE.csv&quot;) #&gt; [1] &quot;2020-September-03_11-06-33_INFILE_clean.csv&quot; The timestamp reflects the time that the function was initially run, rather than the current time. Source of the problem: The Sys.time() function outside the outfile_path definition. The Sys.time is executed when the package is built, but never again. Code outside your functions is only built once at build time. Moving Sys.time so that it’s no longer top level code: # always timestamp as &quot;now&quot; outfile_path &lt;- function(infile) { ts &lt;- timestamp(Sys.time()) paste0(ts, &quot;_&quot;, sub(&quot;(.*)([.]csv$)&quot;, &quot;\\\\1_clean\\\\2&quot;, infile)) } # allow user to provide a time, but default to &quot;now&quot; outfile_path &lt;- function(infile, time = Sys.time()) { ts &lt;- timestamp(time) paste0(ts, &quot;_&quot;, sub(&quot;(.*)([.]csv$)&quot;, &quot;\\\\1_clean\\\\2&quot;, infile)) } Takeaway: Need to have a different mindset when defining objects for a package. The objects should be functions and these functions should (generally) only use data they create or that is passed via an argument. "],["golf-side-effects.html", "6.7 Golf: side effects", " 6.7 Golf: side effects A new concern with the timestamp: The timestamps depend on which part of the world you’re in. location timestamp LC_TIME tz Rome, Italy 2020-settembre-05_00-30-00 it_IT.UTF-8 Europe/Rome Warsaw, Poland 2020-września-05_00-30-00 pl_PL.UTF-8 Europe/Warsaw Sao Paulo, Brazil 2020-setembro-04_19-30-00 pt_BR.UTF-8 America/Sao_Paulo Greenwich, England 2020-September-04_23-30-00 en_GB.UTF-8 Europe/London Proposed Solution: Create timestamps that are all in a fixed time zone. We can force a certain locale with Sys.setlocale() and force a particular time zone by adjusting the TZ environment variable. Our attempt at implementing this: timestamp &lt;- function(time = Sys.time()) { Sys.setlocale(&quot;LC_TIME&quot;, &quot;C&quot;) Sys.setenv(TZ = &quot;UTC&quot;) format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;) } However, a user in Brazil would see this after using outfile_path() from our package: outfile_path(&quot;INFILE.csv&quot;) #&gt; [1] &quot;2022-April-17_07-14-18_INFILE_clean.csv&quot; format(Sys.time(), &quot;%Y-%B-%d_%H-%M-%S&quot;) #&gt; [1] &quot;2022-April-17_07-14-18&quot; Our calls to Sys.setlocale() and Sys.setenv() inside timestamp() have made persistent changes to their R session. This sort of side effect is very undesirable and is extremely difficult to track down and debug, especially in more complicated settings. Solution: # use withr::local_*() functions to keep the changes local to timestamp() timestamp &lt;- function(time = Sys.time()) { withr::local_locale(c(&quot;LC_TIME&quot; = &quot;C&quot;)) withr::local_timezone(&quot;UTC&quot;) format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;) } # use the tz argument to format.POSIXct() timestamp &lt;- function(time = Sys.time()) { withr::local_locale(c(&quot;LC_TIME&quot; = &quot;C&quot;)) format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;, tz = &quot;UTC&quot;) } # put the format() call inside withr::with_*() timestamp &lt;- function(time = Sys.time()) { withr::with_locale( c(&quot;LC_TIME&quot; = &quot;C&quot;), format(time, &quot;%Y-%B-%d_%H-%M-%S&quot;, tz = &quot;UTC&quot;) ) } The locale in our timestamp is only temporarily modified with the withr::with_locale function. In this example, the mistake we made was changing the user’s overall state. If you have to do this, make sure this is documented explicitly or try to make them reversible "],["meeting-videos-5.html", "6.8 Meeting Videos", " 6.8 Meeting Videos 6.8.1 Cohort 1 Meeting chat log 00:45:32 collinberke: Check this out regarding side effects: https://withr.r-lib.org/articles/changing-and-restoring-state.html 00:55:58 Arun Chavan: https://rstats.wtf/ 00:58:05 Isabella Velásquez: https://yihui.org/knitr/options/ 00:59:31 Arun Chavan: +1 for knitr options because the tab autocompletion doesn’t work for them (at least for me) 01:00:58 Brendan Lam: I&#39;m gonna try that "],["r-code.html", "Chapter 7 R code", " Chapter 7 R code Learning objectives: Organize functions into files. Maintain a consistent coding style. Compare and contrast functions in a package versus functions in a script. "],["organise-functions-into-files.html", "7.1 Organise functions into files", " 7.1 Organise functions into files 7.1.1 Only one hard rule Function definitions must be in .R files in the R/ directory. 7.1.2 Conventions File names should be meaningful and convey which functions are defined within The two extremes are bad: One file per function All functions in the same file Group functions into files One function in one file if the function is very large, with lots of documentation Main function and supporting function in one file (e.g. tidyr/R/separate) A family of related functions in one file (e.g. tidyr/R/rectangle.R) One function in one file if the function doesn’t neatly fit any other grouping (e.g tidyr/R/uncount.R) Small helper functions used in functions across different files are typically stored in R/utils.R by convention "],["fast-feedback-via-load_all.html", "7.2 Fast feedback via load_all()", " 7.2 Fast feedback via load_all() Reminder to use load_all() to try out the functions in file under /R. "],["code-style.html", "7.3 Code style", " 7.3 Code style What and why: the tidyverse style guide How: the {styler} package styler::style_pkg() restyles an entire R package. styler::style_dir() restyles all files in a directory. usethis::use_tidy_style() is wrapper that applies one of the above functions depending on whether the current project is an R package or not. styler::style_file() restyles a single file. styler::style_text() restyles a character vector. "],["understanding-when-code-is-executed.html", "7.4 Understanding when code is executed", " 7.4 Understanding when code is executed 7.4.1 When code is executed in scripts vs. in packages Code in scripts, run interactively (in an IDE or with source()) or non-interactively with Rscript: is run … when you run it(!) Code in a package: is run when the package is built Code in /R is executed and results are saved when the binary package is built (often, by CRAN) (“build time”) The cached results are re-loaded and made available for use When you load a package with library() (“load time”) This means that: for macOS and Windows users of CRAN packages, build time is whenever CRAN built the binary package for their OS. for those who install packages from source, build time is when they (built and) installed the package. (Building of the package is what is accomplished by R CMD INSTALL --build, not R CMD build, which makes a bundled package, i.e. a “source tarball”). 7.4.2 Real world example: Sys.time() x &lt;- Sys.time() In a script x tells you when the script was run. In a package, x tells you when the package was built. 7.4.3 Real world example: system.file() The shinybootstrap2 package once had this code below R/ which works fine when the package is built on the same machine as it is used on. dataTableDependency &lt;- list( htmlDependency( &quot;datatables&quot;, &quot;1.10.2&quot;, c(file = system.file(&quot;www/datatables&quot;, package = &quot;shinybootstrap2&quot;)), script = &quot;js/jquery.dataTables.min.js&quot; ), htmlDependency( &quot;datatables-bootstrap&quot;, &quot;1.10.2&quot;, c(file = system.file(&quot;www/datatables&quot;, package = &quot;shinybootstrap2&quot;)), stylesheet = c(&quot;css/dataTables.bootstrap.css&quot;, &quot;css/dataTables.extra.css&quot;), script = &quot;js/dataTables.bootstrap.js&quot; ) ) The solution is to call system.file() from a function, at run time. 7.4.4 Real world example: Aliasing a function 7.4.4.1 Don’t do this foo &lt;- pkgB::blah 7.4.4.2 Do this foo &lt;- function(...) pkgB::blah(...) "],["respect-the-r-landscape.html", "7.5 Respect the R landscape", " 7.5 Respect the R landscape People will use your package in situations that you never imagined. This means that you have to pay attention to the R landscape (i.e. not only available functions and objects, but all the global settings) 7.5.1 Examples of actions that change the R landscape Loading a package with library() Changing global options with options() Changing the working directory with setwd() 7.5.2 How to know when you have changed the R landscape If the behavior of other functions differs before and after running your function, you have modified the landscape. 7.5.3 Tips to avoid changing the landscape with your functions Don’t use library() or require(). Use the DESCRIPTION to specify your package’s requirements. Never use source() to load from a file. Non-exhaustive list of other functions that should be used with caution. options() par() setwd() Sys.setenv() set.seed() Flip side of this is that you shouldn’t rely on user’s landscape. 7.5.4 What if you have to use one of the above functions and alter the landscape? Make sure to clean up after yourself. 7.5.4.1 Manage state with withr withr::defer() is inspired by base::on.exit(). The general pattern is: to capture the original state schedule its eventual restoration then make the state change for example, below, where some setters like options() and par() return the old value when you provide a new one, allowing you to do something like this. f &lt;- function(x, y, z) { ... old &lt;- options(mfrow = c(2, 2), pty = &quot;s&quot;) defer(options(old)) ... } withr::defer() can also be using in the global environment for developing code interactively, and cleaned up with withr::deferred_clear(). 7.5.4.2 Restoring state with base::on.exit() Very similar to withr::defer() Note that we use the add = TRUE argument, which adds to the list of deferred cleanup tasks rather than replace them. g &lt;- function(a, b, c) { ... scratch_file &lt;- tempfile() on.exit(unlink(scratch_file), add = TRUE) file.create(scratch_file) ... } 7.5.4.3 Isolate side-effects Often you can’t avoid creating side effects, e.g. printing output or creating plots Good practice is to isolate them in functions that only produce output. e.g. instead of combining them into one function, write two functions for data wrangling and plotting, respectively. 7.5.4.4 When you do need side-effects Most common when your package talks to an external system You may need to: Display a message when your package loads Set custom options for your package with options() Use .onLoad() and .onAttach() (mostly the former) .onAttach &lt;- function(libname, pkgname) { packageStartupMessage(&quot;Welcome to my package&quot;) } Use .onUnload() to to clean up side effects. .onLoad() etc. are conventionally stored in R/zzz.R "],["constant-health-checks.html", "7.6 Constant health checks", " 7.6 Constant health checks Here is a typical sequence of calls when using devtools for package development: Edit one or more files below R/. document() (if you’ve made any changes that impact help files or NAMESPACE) load_all() Run some examples interactively. test() (or test_file()) check() Experienced developers cycle through these steps frequently and rapidly (remember, fast feedback!). Lack of comfort with these steps often leads to a dysfunctional workflow, that looks look like below, and makes it difficult to spot bugs as they arise. Edit one or more files below R/. Build, install, and use the package. Iterate occasionally with previous step. Write documentation (once the code is “done”). Write tests (once the code is “done”). Run R CMD check right before submitting to CRAN or releasing in some other way. "],["cran-notes.html", "7.7 CRAN notes", " 7.7 CRAN notes If you are submitting to CRAN, you must use only ASCII characters in your .R files. i.e. 0-9, a-Z, common punctuation If you need to use a Unicode character, you can specify it in the special unicode escape “\\u1234” format. x &lt;- &quot;This is a bullet •&quot; y &lt;- &quot;This is a bullet \\u2022&quot; identical(x, y) #&gt; [1] TRUE cat(stringi::stri_escape_unicode(x)) #&gt; This is a bullet \\u2022 "],["meeting-videos-6.html", "7.8 Meeting Videos", " 7.8 Meeting Videos 7.8.1 Cohort 1 "],["package-metadata.html", "Chapter 8 Package metadata", " Chapter 8 Package metadata Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1.html", "8.1 SLIDE 1", " 8.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-7.html", "8.2 Meeting Videos", " 8.2 Meeting Videos 8.2.1 Cohort 1 Meeting chat log LOG "],["licensing.html", "Chapter 9 Licensing", " Chapter 9 Licensing Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-1.html", "9.1 SLIDE 1", " 9.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-8.html", "9.2 Meeting Videos", " 9.2 Meeting Videos 9.2.1 Cohort 1 Meeting chat log LOG "],["object-documentation.html", "Chapter 10 Object documentation", " Chapter 10 Object documentation Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-2.html", "10.1 SLIDE 1", " 10.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-9.html", "10.2 Meeting Videos", " 10.2 Meeting Videos 10.2.1 Cohort 1 Meeting chat log LOG "],["vignettes-long-form-documentation.html", "Chapter 11 Vignettes: long-form documentation", " Chapter 11 Vignettes: long-form documentation Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-3.html", "11.1 SLIDE 1", " 11.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-10.html", "11.2 Meeting Videos", " 11.2 Meeting Videos 11.2.1 Cohort 1 Meeting chat log LOG "],["testing.html", "Chapter 12 Testing", " Chapter 12 Testing Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-4.html", "12.1 SLIDE 1", " 12.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-11.html", "12.2 Meeting Videos", " 12.2 Meeting Videos 12.2.1 Cohort 1 Meeting chat log LOG "],["namespace.html", "Chapter 13 Namespace", " Chapter 13 Namespace Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-5.html", "13.1 SLIDE 1", " 13.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-12.html", "13.2 Meeting Videos", " 13.2 Meeting Videos 13.2.1 Cohort 1 Meeting chat log LOG "],["external-data.html", "Chapter 14 External data", " Chapter 14 External data Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-6.html", "14.1 SLIDE 1", " 14.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-13.html", "14.2 Meeting Videos", " 14.2 Meeting Videos 14.2.1 Cohort 1 Meeting chat log LOG "],["compiled-code.html", "Chapter 15 Compiled code", " Chapter 15 Compiled code Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-7.html", "15.1 SLIDE 1", " 15.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-14.html", "15.2 Meeting Videos", " 15.2 Meeting Videos 15.2.1 Cohort 1 Meeting chat log LOG "],["installed-files.html", "Chapter 16 Installed files", " Chapter 16 Installed files Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-8.html", "16.1 SLIDE 1", " 16.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-15.html", "16.2 Meeting Videos", " 16.2 Meeting Videos 16.2.1 Cohort 1 Meeting chat log LOG "],["other-components.html", "Chapter 17 Other components", " Chapter 17 Other components Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-9.html", "17.1 SLIDE 1", " 17.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-16.html", "17.2 Meeting Videos", " 17.2 Meeting Videos 17.2.1 Cohort 1 Meeting chat log LOG "],["git-and-github-1.html", "Chapter 18 Git and GitHub", " Chapter 18 Git and GitHub Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-10.html", "18.1 SLIDE 1", " 18.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-17.html", "18.2 Meeting Videos", " 18.2 Meeting Videos 18.2.1 Cohort 1 Meeting chat log LOG "],["automated-checking.html", "Chapter 19 Automated checking", " Chapter 19 Automated checking Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-11.html", "19.1 SLIDE 1", " 19.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-18.html", "19.2 Meeting Videos", " 19.2 Meeting Videos 19.2.1 Cohort 1 Meeting chat log LOG "],["releasing-a-package.html", "Chapter 20 Releasing a package", " Chapter 20 Releasing a package Learning objectives: THESE ARE NICE TO HAVE BUT NOT ABSOLUTELY NECESSARY "],["slide-1-12.html", "20.1 SLIDE 1", " 20.1 SLIDE 1 ADD SLIDES AS SECTIONS (##). TRY TO KEEP THEM RELATIVELY SLIDE-LIKE; THESE ARE NOTES, NOT THE BOOK ITSELF. "],["meeting-videos-19.html", "20.2 Meeting Videos", " 20.2 Meeting Videos 20.2.1 Cohort 1 Meeting chat log LOG "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
